{"pages":[],"posts":[{"title":"블로그 방랑자... (이제서야 정착했습니다.)","text":"벨로그에서 쓴 글을 약간 수정함 바로 며칠전에 깃허브 블로그 커스텀할 시간 없다고 벨로그로 임시 정착하겠다고 말했으면서 그새 또 마음이 바뀌어서 깃허브 블로그로 왔다. 벨로그는 무척 좋은 플랫폼이긴 하지만 나처럼 포스팅 양이 많은 사람에게는 조금 부담스런 느낌이 없지않아 있었다.알고리즘 풀이 포스팅이 100개를 넘어가는 상황이 왔을 때에는 벨로그가… 별로 적합하지 않을 것 같다는 느낌이 들어서 주저하지 않고 바로 깃허브 블로그로 (다시…)자리를 잡았다.이젠 더 맘에 들고 말고 할것도 없어서 이제는 여기에 게속 있게 될 것 같다.맘에 안드는 부분이 있으면 수정하면 되니까… 그럼 과거 블로그 히스토리들을 남기며 태그값 하는 이 날것의 글을 마칩니다. 첫번째 블로그 https://lalayeon.postype.com/두번째 블로그 https://lalayeon.tistory.com/세번째 블로그 https://velog.io/@yoou/ 이름에 대한 정말 쓸모없는 이야기 예전부터 이거 말하고 싶어서 손가락이 근질거렸다. yoou는 유-라는 발음을 의도하고 지은건데 (걍 yoon에다가 뒤에 n 뒤집어준것임. 이유는.. 없어요. 작명센스 구려서 메이플 캐릭터도 가나다 돌림자 씁니다..) 동생이 yoou 보자마자 요우 라고 읽어서 엄청 당황했다. ㅋㅋㅋㅋ 요우 ㅋㅋㅋㅋㅋㅋ 웃음밖에 안나오는… 그래도 뭐 I love yooou😍😭😍😭 하는 해외 케이팝 팬들의 댓글도 많이 봤었던거 같고.. 그래서 구글 번역에 yoou를 쳐서 발음을 들어봤는데 경쾌하게 들리는 요우. 그렇게 요우가 되었습니다. 이름을 바꾸고싶었는데 사실 yoou보다 더 사람들이 많이 안쓰고 맘에 드는 그런 이름을 찾을 자신도 없고… 현실에서 yoou를 발음하는 것을 들어본게 구글번역기랑 동생밖에 없기 때문에 다른 사람들은 요우라고 읽어주지 않고 유우나 유로 읽어주길 바라면서 그냥 두기로 했다. (하지만 요우.. 계속 발음하다 보니 좀 귀여운것 같기도 하다. (근데 좀 경박해 보이는건 팩트임… 요우🤘)) 그냥 그렇다고요… 그냥 너무 말하고 싶었음.","link":"/2021/03/30/first-post/"},{"title":"🏊‍♀️ 42서울 라피신 후기 (1)","text":"기존에 벨로그에 작성한 글을 옮긴 것입니다 42seoul 4기 1차 라피신 등록에 성공해서 2월부터 3월 중순까지 (중간에 코로나 관련 이슈로 1주일 중단이 있었음) 라피신 과정에 참여했다.피신 과정이 끝난지는 일주일 정도가 지났는데 이제서야 후기를 쓰는 이유는 본과정 결과 나오면 자기반성도 포함해서 후기를 쓰려고 했는데 일주일정도 지나니까 약간 피신기간이 꿈같이 아득해져서…(표현이 너무 문학적인가 싶은데 진짜 그렇게 열심히 했던 한달간의 기간이 꿈같다.) 이러다간 한달 뒤에는 정말 아무것도 기억나지 않을 것 같아서 지금이라도 후기를 써 보려고 한다. 🤷‍♀️ 42서울에 지원한 계기나는 개인적으로는 개발자 친구를 만들기 위해서 42서울에 지원했다.프로젝트 같이 할 사람 구하기도 힘들었고, 주위에 개발에 관심있는 사람이 별로 없었기 때문에 같은 관심사를 가진 사람들끼리 함께 머리를 맞대고 공부한다는 42의 시스템이 굉장히 매력적이라고 생각했다.플러스로 학교 생활과 병행이 가능한 점도 지원한 이유 중 하나였다.물론 라피신 과정은 뒤에서 말하겠지만 다른 일과의 병행이 절대 무리지만 본과정은 아무래도 라피신 과정보다는 조금 여유가 있다고 들었기 때문에 소마나 사피 같은 다른 비슷한 프로그램과는 달리 학교생활을 마무리 하면서 진행할 수 있다는 점에서 42서울에 지원해야 겠다는 생각을 하게 되었던 것 같다. 🏃‍♀️ 라피신 등록하기일단 시작부터 정리를 하면… 체크인 미팅을 힘들게 성공했었던 기억이 난다.첫번째 시도와 두번째 시도 모두 피씨방에서 시도했는데 첫번째 시도에는 순진하게 열리는 시간 정각에 새로고침 하다가 결국에는 500번대의 대기자로 등록을 했고…두번째 시도에서는 든든한 용병(동생 고마워..ㅜ)을 섭외했고 용병이 잡아주었다. 지금은 서버가 좀 튼튼해졌을지는 모르겠지만 내가 신청할 당시에는 신청버튼이 열린다는 그 시간 정각에 새로고침을 누르면 서버가 터져있고 이미 신청할 사람들은 신청을 다 하고 대기순번도 많이 밀려있는 상태였기 때문에 개인적으로는 5분 전부터 새로고침을 하고 있는것을 추천한다.물론 서버가 굉장히 허약하기 때문에 5분 전부터 버벅이기 시작하겠지만… 원래 티켓팅은 실력 30% 운 70%로 승패가 갈리는 것이다. 피신 동안에도 계속 나오는 말이지만 분하게도 세상은 불공평하기때문에 신청에 실패하면 그냥 운이 나빴다고 생각하고 털어내 버리는게 정신건강에 좋더라…아무튼 서버가 버벅이는 와중에서도 운이 좋아 신청버튼이 열리고 그걸 잽싸게 누르면 체크인 미팅에 성공한 것이 된다. 체크인 미팅은 초기 기수에서는 오프라인으로 진행되었다고 하던데 내가 알기론 3기부터는 온라인으로 체크인 미팅이 진행되었다. 긴장할 필요가 있는 것은 아니고 그냥 본인 확인을 위한 절차이다. 줌으로 진행되었던 것 같은데 준비하라는 것 잘 준비해서 내가 그 신청자 본인이다라는 것만 증명하면 필요 절차는 끝나고 그 이후에 단체로 조금 긴 42에 관련된 영상을 보고.. 질의응답 시간을 가졌다. 많은 질문들이 있었지만 기억에 남는 질문이 다른 일과 병행이 가능한지에 대한 질문이었는데 개인적으로 답변을 해보자면 지원금이 목표라면 가능, 본과정이 목표라면 절대 불가능이라는 답을 해주고 싶다. 이 얘기는 조금 길어질 것 같아서 뒤로 미루겠지만 아무튼 병행은 진짜 무리다. 대학을 다니면서 온라인 수업을 하면서 듣는것도 학기 초반이었지만 정말 정신이 하나도 없어서 출결을 놓치기 일쑤였다. 아무튼… 그랬다. 체크인 미팅을 마치고 나면 이제 라피신 등록을 해야 한다. 이것도 마찬가지로 선착순이고 나는 이번에도 피씨방에서 성공했다. 여기에 대해서는 별로 할 말이 없다… 진짜 운이 좋게 신청에 성공했다. 🏊‍♀️ 본격 라피신격일 출석전염병 때문에 클러스터(교육장)에 격일로 출석할 수 있었고 출석하지 않는 시간에는 원격접속으로 과제를 할 수 있었다.출석 날짜에 맞춰서 1그룹과 2그룹으로 나뉘어졌는데 나는 2그룹이었다. 피신기간동안 좋은 의미로든 나쁜 의미로든 돌발 이벤트가 종종 있었는데 기분 탓인지는 몰라도 1그룹에는 좋은 이벤트가 많이 생겼었고 2그룹에는 좋지 않은 이벤트가 종종 있었다. 2그룹 사람들끼리 1그룹 부럽다고 종종 불평하긴 했었는데 세상은 불공평하다니 어쩔 수 없다.원격접속은 클러스터 내부의 아이맥에 원격으로 접속하는 방법으로 이루어졌었는데 물론 많은 직원분들이 기술적 이슈들을 해결해주시려 노력해주시긴 했지만 원격접속 환경은 생각보다도 더 별로였다. 망할 전염병… 첫날첫날 가서는 혼란의 연속이었다. 나도 라피신 이전에 이전 기수들의 후기글을 많이 찾아봤고 맥을 사용하기 때문에 맥 사용법을 잘 알아가면 좋다는 글, 질문을 두려워하면 안된다는 글 등등을 정~말로 많이 봤지만 솔직히 맥 사용법 공부해가는 것은 별로 도움이 안되었던 것 같다.막상 가서는 전원버튼 잘못 눌러서 무한로딩이 걸려서 엄청 당황했었고 한영전환도 어떻게 하는지 몰라서 슬랙을 엄청 뒤적거렸고 과제도 어떻게 시작하는지 몰라서 좀 두리번거리다가 눈치껏 시작했었던 기억이 있다. 정말 말 그대로 수영 못하는 사람들 수영장에 빠뜨린 느낌… 첫날에 뼈저리게 느꼈다. 이건 생존의 문제다… 첫날 근처에 앉아있었던 사람들이랑 피신과정 끝날때까지 쭉 같이 지내는 사람들이 많았는데 나는 사람들을 얕고 넓게 사귀는 것을 잘 못해서… 첫날 같이 밥 먹었던 사람들이랑은 이후에 한번도 연락을 안했었다.(ㅋㅋㅋㅋ) 잘 살아남으셨나요… 궁금하네요… 첫번째 과제가 한 9문제 정도 있었던 것 같은데 나는 문제도 이해가 잘 안가고 사용개념도 잘 모르겠어서 3번인가 4번 정도에서 막혀서 구글링 열심히 하고 있었는데 옆사람이 “혹시 8번 어떻게 푸는지 아세요?”라고 물어봐서 멘탈이 터졌던 기억이 있다.지금 생각해보니 그때 “저 지금 3번에서 막혀서 8번 보지도 못했어요ㅜㅜ” 하면서 3번문제 질문했으면 참 좋았을 것 같긴한데 어찌나 말이 안나오던지ㅋㅋㅋ 결국에는 첫날 질문은 하나도 못하고 혼자 멘탈만 터져서 집에 왔었다. 동료평가20년 넘게 다른 사람에게 먼저 말 못걸고 살아왔는데 갑자기 성격이 싹 바뀌어서 넉살좋게 혹시 이거 아시나요~? 하고 물어볼 수 있을리가 없다.그래서 나는 동료평가를 열심히 다니기로 했다. 동료평가는 1대 1 코드리뷰 같은 느낌이다. 내 코드를 설명하는 과정인데 과제를 끝내기 위해서는 꼭 동료평가를 몇번 받아야 한다.내가 동료평가를 할 수 있는 시간에 평가 슬롯을 열어두면 평가가 필요한 사람이 그 시간에 맞게 신청을 해서 내가 그 사람의 코드를 보면서 평가를 해주면 된다.이름은 동료평가지만 엄밀히 말하면 그 사람의 코드 설명을 듣는 것에 좀 더 가깝다. 그래서 내가 막혀있는 문제의 동료평가를 하러 가게 되면 내가 해결 못하고 있는 부분에 대한 설명을 들을 수 있고 추가설명도 요구할 수 있기 때문에 나같이 질문을 못하는 사람이 있다면 동료평가 기회를 적극 활용하면 좋을 것 같다. 다만 이 방법은 멘탈이 약한 사람에게는 별로 추천하지는 않는데 내가 무언가에 막혀서 동료평가를 하러 다닌다는 것은 누군가는 과제를 다하고 평가를 받고있다는 것과 같다. 생각보다 동료평가가 시간이 많이 걸리기 때문에 질문을 위해서 평가를 많이 다니게 되면 자연스럽게 내 진도는 늦어진다. 이렇게 되면 나보다 진도가 빠른 사람을 상대할 가능성이 높아지기 때문에 나는 문제를 읽지도 못했던 과제를 설명듣는 경우도 생각보다 많았다. 이런 상황에서 피평가자분의 능수능란한 설명을 듣다보면 약간 자괴감 들고 괴롭더라… 아무튼 나는 내 나름대로의 생존방법으로 동료평가를 활용한 것이고 이 글을 읽으실 분들도 나름대로의 생존 방법을 찾으시길 바란다. 당연히 시간 절약을 위해서는 뻔뻔하게 옆사람에게 질문을 하는 것이 좋다. 나도 질문을 많이 받아본 입장에서 어떤 사람이 나에게 질문을 하면 ‘이사람 이것도 몰라?’하는 느낌보다는 ‘나에게 질문을 해주다니 내가 잘 아는 사람처럼 보였나?’하고 기분이 좋다. 이걸 알면서도 왜 나는 질문을 못하는진 모르겠지만.그리고 초반에야 낯설어서 동료평가로 질문기회를 대신했지만 중후반부에 가서는 나 역시도 모르는거있으면 막 물어보고 그랬다. 42의 문화에 익숙해져야 수영장에서 살아남을 수 있다. 과제원칙적으로 42과제를 포함해서 42에 관련된 컨텐츠들은 절대 외부로 유출되면 안되지만(첫날에 보안유지 각서를 쓴다ㄷㄷ) 솔직히 시작한지 좀 오래된 과정이기 때문에 구글링을 좀만 열심히 해봐도 전 세계에서 라피신 과정을 했던 사람들의 코드를 찾을 수 있다. 하지만 그거 그대로 베껴서 가면 과제는 통과해도 동료평가에서 금방 들통이 나고 (물론 동료평가에서 치팅으로 점수를 깎는 분은 한번도 본 적이 없었지만 코드 베낀 사람은 이유 설명하는 과정이랑 변수, 함수 네이밍에서 티가 엄청 난다) 시험 점수에서도 결과로 들통이 나기 때문에 왠만하면 그냥 본인이 직접 머리싸매고 과제를 해결하는 것을 추천한다. 시험매주 금요일은 시험날이다. 물론 시험에 대한 안내사항도 친절하게 표면적으로 알려주지 않기 때문에 알아서 잘 챙겨서 해야할 모든 것들을 시험 전에 완료해놔야 시험을 정상적으로 치를 수 있다. 이미 유명한 썰(?)이긴 하지만 첫 시험에서 시험 시작조차 못해서 사람들이 우르르 나가는 것을 보고 너무 충격이었다. 나도 해줄 수 있는 말은 별로 없지만… 과제 치팅하지 말고 매뉴얼을 잘 읽자라는 말은 꼭 해주고 싶다.시험은 서버에 저장되어있는 여러 레벨에 해당되는 문제들이 랜덤으로 나오는 형태이다. 그래서 같은 시험을 본 사람들이라도 푼 문제들이 다 다르다. 같은 레벨의 문제라고 하더라도 난이도가 좀 다르기 때문에 불공평하다고 느낄 수 있겠지만 시험 안내문에도 적혀있듯이 세상은 불공평하기 때문에 어쩔 수 없다고 한다. (라피신 하면서 정말 인생을 불공평하구나 하는 것을 뼈저리게 느끼고 간다.)한 문제를 통과하지 못하면 다음 단계의 문제로 넘어갈 수 없고 제출 후에 계속 오답이 누적되면 일정 시간을 기다려야만 다시 제출할 수 있는데 그 시간이 점점 늘어난다. 나는 좀 신중하게 제출하는 타입이라 최대로 많이 기다려 본 적이 20분 정도였지만 길게 기다린 분은 한시간 정도도 기다렸다는 것 같다.시험 성적이 본과정 합격에 큰 요소가 되는지는 모르겠지만 나처럼 팀과제를 모두 빵점 받은 사람에게는 시험이 레벨 상승에 정말 도움이 많이 되었다. 제발 합격 요소에 시험점수가 들어가야하는데…. 물론 시험문제는 쉽지 않지만 매뉴얼을 잘 읽고 과제를 잘 했으면 시험도 어느 정도 선까지는 무리없이 풀 수 있는 것 같다! 팀과제시험이 끝나면 미리 신청해둔 팀 과제의 팀 구성이 나온다. 피신 기간동안 팀과제를 총 4번 하게 되는데 (랜덤으로 조가 짜이는 것 3개, 직접 팀원을 구성해서 하는 것 1개) 나는 넷 다 0점을 받았다. 시간은 시간대로 엄청 쓰고(4개의 과제 모두 이틀을 꼬박 투자했었다) 0점받아서 솔직히 허탈하긴 한데 협업 경험이 많이 없는 나로써는 꽤 좋은 경험이었다고 생각한다.첫번째 두번째 팀 과제가 진행된 뒤에 세번째 팀 과제와 BSQ(위에서 말한 직접 팀원을 구성해서 하는 팀 과제)를 포기하고 개인과제에 집중하는 사람들도 있었지만 개인적으로는 세번째 팀 과제와 BSQ가 진짜 재밌었다. 물론 정말 어려워서 구현도 제대로 못하고 마치는 분들도 많긴 했었지만 나는 운좋게 나랑 비슷하거나 좀 더 잘하시는 분들과 같이 팀이 짜여져서 같이 끙끙대면서 코딩하는 것이 너무 재밌었다.이자리를 빌어 저와 같이 팀 과제 해주신 모든 분들께 감사함을 표합니다… 같이 밤새주고 과제 해줘서 정말 고맙습니다. 1, 2, 3주차 간단정리1주차 : 동료평가를 비롯한 42시스템에 익숙해지는 시간. 이 시기에는 다들 진도가 비슷비슷하기 때문에 서로 으쌰으쌰 하는 분위기가 형성된다.2주차 : 슬슬 진도가 차이나기 시작한다. 팀과제를 하고 시험을 보고 나니 피시너들간 레벨 차이도 확실히 나기 시작한다. 팀과제 100점 받은 사람들 프로필 보면서 부러워하기 시작함…… 멘탈 일부 날아감3주차 : 몸과 마음이 힘들다. 머리가 잘 안굴러가서 다른 피시너 프로필 타고타고 구경하고 있었는데 다들 나보다 레벨이 높아서 조금 우울해졌다. 밤샘을 밥먹듯 하니까 몬스터 섭취량은 늘어가고 (정말로)눈가가 퀭해짐. 플러스로 학교 개강도 했다… 이 시기에는 정말 정말 좀비처럼 다녔다. 마지막 날 + final exam마지막 날에 BSQ 평가를 받았는데 진짜 당일 새벽 5시까지 밤새고 제출 직전까지 기능 하나 꾸역꾸역 추가해서 어느정도 어려운 부분 구현까지 다 완료했는데 그 추가한 기능이 실행이 안되어서 (분명히 됐는데! 안됐다! 팀원분과 계속 우리가 본 것은 허상이냐며 이곳저곳에서 몇번이고 시도해봤는데 안되어서… 결국 수긍했다. 근데 진짜 억울함 분명히 됐었는데…ㅜㅜ) 0점을 받아버리고 멘탈이 바스러진 상태로 마지막 개인과제를 하고 평가를 받았다. 마지막 주가 되어서는 다들 개인과제 진도를 나간다고 동료평가 슬롯을 잘 열지 않기 때문에 개인과제 동료평가 잡기가 정말 티켓팅 급으로 어려웠다. 나도 마지막 과제 하던거는 완료해야지 싶어서 평가 잡는다고 새로고침 오백만번 누르고 나서야 새벽 1시 30분에 평가를 마치고 집에 갈 수 있었다. final exam은 아침 10시부터 8시간동안 진행되었다. 전염병 전 기수 사람들에게는 중간에 도시락이나 샌드위치가 제공되었다는 것 같지만… 우리는 많은 인원의 실내 식사가 금지된 탓에 걍 쫄쫄 굶으면서 시험을 봤다.사실 나는 8시간 앉아잇는것은 일도 아니라 시작부터 끝까지 한번도 일어나지 않고 시험을 보긴 했지만 옆에서 시험을 보신 분은 정말 힘들어하시는 것 같았다. 오래 앉아있는게 힘든 사람들은 중간중간 화장실이나 물마시러 가면서 스트레칭 하는 게 좋을 것 같다. 마지막 시험은 결국 좀 아쉬운 점수로 마무리 했다. 한 세시간 정도만 더 있었어도 마지막 풀던 문제까지는 마무리할 수 있었을 것 같은데(ㅋㅋㅋㅋ) 전날 5시까지 BSQ하고 2시간 자고 다시 클러스터와서 개인과제 하고 평가받는다고 새벽 2시넘어서 집에 도착하고 다시 아침 10시에 시험보러가서 8시간동안 빡세게 집중하려니 6시간 정도 쯤 되니까 머리속이 뒤죽박죽이 되어가지고 정상적인 사고가 불가능했다… 솔직히 남은 2시간은 이상한데서 한 실수 잡느라고 다 날려버렸다…ㅜㅜ 그렇게 약간 아쉬운 진도와 약간 아쉬운 레벨로 라피신을 마무리하게 되었다. 마지막 컨디션 조절이 문제였던 것 같음… 글이 좀 길어지는 것 같아 뒷 내용은 다른 글에다 적으려고 한다.너무 한큐에 글을 써가지고 좀 두서가 없는 것 같은데 퇴고는 뒷 글 다 쓰고 한번에 해야겠다…","link":"/2021/03/30/42-seoul-la-piscine-review-1/"},{"title":"🏊‍♀️ 42서울 라피신 후기 (2)","text":"기존에 벨로그에 작성한 글을 옮긴 것입니다 😫 개인적으로 힘들었던 부분앞글에서도 말했지만 나는 사람을 얕고 넓게 사귀는 것을 잘 못한다.한번 친해지면 끝까지 가는 경향이 있어서 친해지는 그 시작에서 에너지를 많이 쏟게 되는데 라피신 하면서 동료평가 자주 가서 얼굴만 익힌 사람은 물론이고 주말동안 팀과제 하나로 계속 붙어있었던 사람, 하루동안 근처에 앉아가지고 계속 질문하고 질문받았던 사람, 심지어는 그냥 지나가다가 과제는 잘 되어가세요? 하고 질문해주시는 사람, 이런 얕은 인간관계의 시작만 계속되다보니까 솔직히 좀 힘들었다.새로운 사람을 만나는 것은 너무 즐거웠지만(좋은 분들을 많이 만날 수 있어서 감사한 시간이었음) 가볍게 지나가는 사람들이 너무 많아서 힘들었다… 뭔가 몇명의 사람들과 계속 진득하게 친하게 지내면서 여러 사람을 만났으면 이렇게 힘들진 않았을 것 같긴 한데 매번 다른 사람과 새로 친해지고 이래서 좀 힘들었던 것 같다. 솔직히 이건 너무 개인적 문제인 것 같기도 하고. 식사문제도 있었다.강남역에 몇번 가본 사람은 알겠지만 강남역에서 먹을만한 식당들은 2호선 출구들 근처에 많고 못해도 신분당선 출구쪽에는 와야 선택지가 좀 늘어나는데 아쉽게도 클러스터가 있는 건물은 강남역이랑 양재역 사이에 있어서 찐 식사류(밥…밥!)를 먹으려면 4번출구쪽으로 쭉 내려가야 하거나 아니면 새로운 맛집을 찾아나서야 했다. 아니면 맥도날드나 에그드랍, 서브웨이같은 것들로 간단하게 식사를 해결해야 했는데 이게 한달동안 계속되니까 본가에서 다님에도 불구하고 집밥 먹으니까 눈물나는 지경이 되었다.식사 종류 문제도 있었지만 밥 시간이 일정하지 않은것도 문제였다. 동료평가 슬롯을 정신없이 열고 정신없이 동료평가 예약을 잡다보면 밥시간을 못지키기 일쑤였다. 점심과 저녁을 둘다 잘 챙겨먹은적이… 한달동안 5번도 안되는 것 같다. 그니까 하루에 서브웨이 터키 15센치 하나 먹고 버틴적도 너무 많았다. 물론 너무 힘들어서 입맛도 별로 없긴 했었는데 잠 못자고 밥 못먹고 코딩만 하니까 정말 코딩좀비가 된 것 같았다. (글쓰는거 보니까 지금 상태도 약간 좀비인 것 같은데?) 2주동안이긴 했지만 학교수업과 병행하는 것도 좀 힘들었다.학기초라 오티기간 1주, 찐 수업기간 1주긴 했는데 그 1주도 못벼텨서 개강 둘째주부터 출결이 2개나 구멍이 나버렸다..ㅋㅋ 후술하겠지만 비대면 인강이니까 완전 가능하겠지~ 라고 생각했던 건 너무 자만이었다. 😎 개인적 결론라피신을 한달동안 해보고 나니 이 과정이 어떤 분들에게 괜찮을지 대충 감이 왔다. 일단 취준 과정 중에 공백기를 채우기 위해서 라피신을 신청하신 분들은 많은 경우에서 과정을 중단하고 떠나셨다고 한다. 라피신 자체로는 솔직히 취업에 직접적으로 도움이 되지 않는 과정이라고 생각하기 때문에 어느정도는 떠나신 분들이 이해가 갔다.취업이 급하신 분들은 한달이라는 적지않은 시간동안 C와 리눅스를 공부하는 것에서 시간이 아깝다고 느끼실 수도 있을 것 같다. 또한 현실적으로 진로가 명확한데 취준 시간이 부족한 분들에게도 라피신 과정이 적합하지 않을 수 있다는 생각을 했다. 라피신 과정동안은 정말 아무것도 못하고 라피신만 해야 한다. 나는 피신과정동안에 졸업 프로젝트 관련해서도 할일이 이것저것 많았고 3월이 되고 나서부터는 원격수업도 챙겨서 들었어야 했는데 결론적으로는 피신 이외의 다른 일들은 완전히 엉망진창이 되었었다. 클러스터에 출석하는 요일에는 아침 9시부터 빠르면 밤 11시, 늦으면 새벽 2시까지 클러스터에만 앉아있었고 원격접속 시간에도 스터디하랴 개인과제 진도 나가느랴 하루동일 컴퓨터 앞에만 앉아 있었다. 그런데 그 시간동안에 열심히 한게 C와 리눅스였다. 솔직히 이 과정은 컴퓨터공학과 1~2학년 전공 기초에 해당하는 과정이기 때문에 나부터도 ‘본과정 떨어지면 한달동안 배운것으로만 치면 조금 아까울수도 있겠다’하는 생각이 들었다. 그럼 어떤 분들에게 추천을 하냐 하면 개발자의 길이 나에게 맞는지 확인하고자 하는 분들 취준 기간에 여유가 있는 분들 다른 개발자들을 많이 만나고 싶은 분들 이라고 생각하고 있다. 개발을 접해보지 않은 사람들이 42의 과정을 접하면 굉장히 신선하다 라는 느낌을 얻을 수도 있겠지만 개발을 독학으로 공부하신 분들이나 전공한 분들은 솔직히… 이전의 공부하던 방식과 크게 다르지 않다고 느낄 것이다. 나부터도 그랬고. 피신기간 동안에 만난 비전공자분과 이야기하면서 나온 말인데 그분은 전공 공부 중에 질문이 있으면 교수님께 메일을 보냈고 이렇게 과제를 하면서 밤샘 해본적이 그렇게 많지는 않다는 말씀을 하셨다. 그에 반해서 나는 전공 공부중에 궁금한 점이 있으면 무조건 구글링 + 매뉴얼 사이트 검색 + 동기에게 질문 의 방식으로 궁금한 점을 해결했고 과제로 인한 밤샘(ㅋㅋ)은 일상이었다. 그동안 개발을 접해보지 않은 분들이 본인이 개발자로써 평생을 살아도 괜찮을지 경험해보는데에는 라피신이 엄청 도움이 될 것 같다. 라피신 과정을 잘 마쳐서 본과정에 가게 되면 그것도 이후의 커리어에 꽤 많은 도움이 될 것 같고. 두번째로는 취준 기간에 여유가 있는 분들에게 추천하고 싶다. 이전에 개발을 접했든 안 접했든 취준 기간에 여유가 있으면 피신기간인 한달정도 CS관련 지식 정리도 할겸 리눅스랑 C공부 열심히 하고 본과정에 가서는 공통과제 하면서 겸사겸사 본인이 원하는 공부도 찾아서 하고, 공통과제가 1년정도 걸린다고 했던 것 같은데 그거 하고나면 이제 분야별로 선택해서 할 수 있으니 하여간 시간만 충분하다면 엄청 좋은 프로그램임은 확실한 것 같다. 근데 만약 6개월~1년 안에 취업을 해야 하는 사람이 42과정을 한다면… 뭔가 주객전도 되는 느낌이 좀 들 수도 있을 것 같다. 마지막으로는 다른 개발자를 많이 만나고 싶은 분들에게 추천한다. 독학으로 개발을 공부하신 분들은 더 그렇겠지만 지금 본인이 어떤 수준인지, 다른 사람들은 어떻게 공부하는지 들을 기회가 많지 않다. 나부터도 이렇게 개발에 의욕 넘치는 분들을 많이 만난적이 처음이기도 하고. 실제로 피신동안 만난 전공자분들이랑 얘기해봤을 때 프로젝트 같이 할 사람 구하려고 (커뮤니티 형성이라고도 할 수 있겠다) 지원했다는 분도 많이 계셨다. 42 과정에 대한 이해가 부족해 힘들게 라피신을 신청하고서도 과정을 포기하시는 분들이 많아서 안타까운 마음에 주저리 주저리 길게 적어봤다. 하지만 나는 일개 초짜 개발자이기 때문에 내 말을 너무 믿진 마시고 본인이 정말 해야겠다 하고 싶은 마음이 있으면 신청해서 경험해보는게 제일 좋습니다… 날 믿지 마세요… 👫 마무리내가 다시 라피신을 할 수 있다면 좀 더 몰입해서 개인 과제를 해서 레벨과 진도를 높이고, 팀과제에서도 이런저런 실수를 하지 않고 확실히 챙겨서 어이없는 0점을 만들지 않았을거고, 인간관계도 좀 잘 챙겨서 피신이 끝나고도 계속 연락할 수 있는 인연을 만들었을 것 같다.물론 모든 일이 끝나면 후회와 아쉬움이 남지만 라피신은 일생에 딱 한번밖에 할 수 없는 과정이니까 더 아쉬움이 짙게 남는 것 같다. 위에서 ‘솔직히 배운것들로만 치면 한달 좀 아까울수도 있겠다’라고 말했는데 피신과정 전체를 두고 보면 나는 굉장히 가치있는 한달을 보냈던 것 같다. 지식적으로 배운것은 많지 않기는 하지만 개발자들과 소통하는 방법을 배웠고, 다른 사람에게 내 코드를 이해시키는 방법을 배웠고, 다른 사람이 이해할 수 있도록 신경써서 코드를 짜는 습관을 기를 수 있었다. 무엇보다도 나는 개발이 즐겁기 때문에 비록 밥도 못먹고 잠도 못자고 좀비마냥 코딩하긴 했지만 눈감았다 뜨면 코딩하고 꿈에서도 터미널화면 나오고 이런 삶을 한달동안 사니까 되게 재밌었다.(정말입니다) 이 즐거움을 계속 느끼고 싶네요… 본과정 가고싶습니다…본과정 결과가 나오면 다시 후기를 쓰도록 하겠습니다. (눈물의 후기 싫어요)이것도 정제되지 않은 이야기 태그를 붙여야 하는거 아닌가 싶을정도로 너무 얼레벌레 후기를 썼네요… 혹시나 봐주신 분들 계시다면 고생 많으셨습니다…(ㅋㅋㅋ) 사죄의 의미로 궁금한 점이 있으시다면 댓글 남겨주시면 최선을 다해서 제가 말할 수 있는 범위내에서 잘 답변해드릴게요…","link":"/2021/03/30/42-seoul-la-piscine-review-2/"},{"title":"(프로그래머스) 신규 아이디 추천 (C++)","text":"문제 링크 문제신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요. [7단계의 처리 과정] 1단계: new_id의 모든 대문자를 대응되는 소문자로 치환합니다. 2단계: new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다. 3단계: new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다. 4단계: new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. 5단계: new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다. 6단계: new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다. 7단계: new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다. 풀이string의 함수들을 잘 사용해서 문제의 조건들을 단계별로 구현해주면 되는 문제였다.별도로 생각해 줄 것 없이 문제 그대로만 잘 구현하면 해결이 되는 문제라 string 관련 함수들만 잘 알고 있다면 무리없이 풀 수 있는 문제이다.사용한 함수들이 궁금하다면 여기 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string solution(string new_id) { string answer = &quot;&quot;; int i = 0; //step 1: 대문자를 소문자로 치환 for(i = 0; i &lt; new_id.length(); i++){ if(new_id[i] &gt;= 'A' &amp;&amp; new_id[i] &lt;= 'Z') new_id[i] = tolower(new_id[i]); } //step 2: 소문자, 숫자, 빼기, 밑줄, 마침표만 answer에 추가 for(i = 0; i &lt; new_id.length(); i++){ if((new_id[i] &gt;= 'a' &amp;&amp; new_id[i] &lt;= 'z') || (new_id[i] &gt;= '0' &amp;&amp; new_id[i] &lt;= '9') || new_id[i] == '-' || new_id[i] == '_' || new_id[i] == '.') answer.push_back(new_id[i]); } //step 3: 마침표가 2번 이상 연속되면 하나 지우기 i = 1; while (i &lt; answer.length()){ if (answer[i - 1] == '.' &amp;&amp; answer[i] == '.'){ answer.erase(answer.begin() + i); continue; } i++; } //step 4: 처음과 끝의 마침표 제거하기 if(answer[0] == '.') answer.erase(answer.begin()); if(answer[answer.length() - 1] == '.') answer.erase(answer.end() - 1); //step 5: 빈 문자열이라면 &quot;a&quot; 대입하기 if(answer.length() == 0) answer.push_back('a'); //step 6: 길이가 16 이상이면 16번째 문자부터 끝까지 제거하기 (제거 후 끝 마침표 제거) if(answer.length() &gt;= 16){ answer.erase(answer.begin() + 15, answer.end()); if(answer[answer.length() - 1] == '.') answer.erase(answer.end() - 1); } //step 7: 길이가 2 이하라면 길이가 3이 될때까지 마지막 문자 붙이기 if(answer.length() &lt;= 2){ char c = answer[answer.length() - 1]; while(answer.length() != 3){ answer.push_back(c); } } return answer;}","link":"/2021/03/30/programmers-72410/"},{"title":"(프로그래머스) 문자열 내 마음대로 정렬하기 (C++)","text":"문제 링크 문제문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다. 풀이처음 문제를 봤을 때에는 n번째 인덱스의 문자가 같을 경우 내림차순일 경우 이렇게 두가지의 경우로 나누어서 풀려고 그랬는데 코드가 뭔가 불필요하게 길어지고 이상하게 헷갈리고 그래서 다른 방법을 생각해보았다. 어떠한 특정한 기준이 주어지고, 그 기준을 갖고 정렬하는 문제이기 때문에 sort 함수를 사용하고 cmp 함수에다 그 기준을 구현해주면 간단하게 코드를 짤 수 있을 것 같았다. 12345bool cmp(string a, string b){ if(a[idx] == b[idx]) return(a &lt; b); return(a[idx] &lt; b[idx]);} 이렇게 n번째 인덱스가 같을 경우에는 사전 순서 기준으로 비교하고, 그 외의 경우에는 n번째 인덱스 순서 기준으로 비교하도록 cmp 함수를 구현해 준 다음에 1sort(answer.begin(), answer.end(), cmp); sort 함수를 이용해서 정렬해주었다. 코드123456789101112131415161718192021#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int idx;bool cmp(string a, string b){ if(a[idx] == b[idx]) return(a &lt; b); return(a[idx] &lt; b[idx]);}vector&lt;string&gt; solution(vector&lt;string&gt; strings, int n) { vector&lt;string&gt; answer; answer.assign(strings.begin(), strings.end()); idx = n; sort(answer.begin(), answer.end(), cmp); return answer;}","link":"/2021/03/31/programmers-12915/"},{"title":"(프로그래머스) 폰켓몬 (C++)","text":"문제 링크 문제당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. 풀이문제가 조금 길었는데 짧게 문제를 요약하면N마리의 폰켓몬 중에서 가장 많은 종류로 N/2마리의 폰켓몬을 뽑았을 때 그 종류의 수를 구하는 문제이다. 결과로 나올 수 있는 종류의 경우가 2가지 있는데 주어지는 폰켓몬의 종류가 N/2종류 이상일 경우에는 뽑을 수 있는 가장 많은 종류의 수가 N/2개가 된다. 주어지는 폰켓몬의 종류가 N/2종류 미만일 경우에는 뽑을 수 있는 가장 많은 종류의 수가 주어지는 폰켓몬의 종류가 된다. 따라서 첫번째로 한 일은 주어지는 nums 벡터에서 폰켓몬의 종류별로 개수를 세어준 것이다.종류 번호는 중복이 없어야 하기 때문에 map을 이용하는 것이 편할 것이라고 생각해서 &lt;int, int&gt; 형태의 map을 선언해 주었고, key값을 종류, value값을 그 종류에 해당하는 폰켓몬의 개수로 설정해주었다. 두번째로 한 일은 map의 원소의 개수(ponketmon.size()), 즉 nums 배열에 있는 폰켓몬의 종류의 개수와 N/2(nums.size()/2)를 비교해 준 것이다.위에서 정리한 것처럼map의 원소의 개수가 N/2보다 크거나 같을 경우에는종류당 하나씩 뽑아서 최대 N/2종류의 폰켓몬을 뽑을 수 있게 되므로 answer가 N/2이 된다.map의 원소의 개수가 N/2보다 작을 경우에는최대한 많은 종류를 뽑아야 하므로 먼저 각 종류당 1개씩 뽑아준 다음에 남은 것들은 이미 뽑은 종류들 중에서 뽑을 수 밖에 없기 때문에answer가 nums 배열로 주어진 폰켓몬의 종류의 개수, 즉 map의 원소의 개수가 된다. 지금 생각해보니까 어떤 종류를 몇개 뽑는지를 구하는 문제가 아닌 그냥 뽑을 수 있는 종류번호의 개수만 구하면 되는 문제이기 때문에 종류번호에 해당하는 폰켓몬의 수를 맵으로 관리해줄 필요가 없다는 생각이 들었다.이렇게 하면 굳이 맵을 사용하지 않고 주어지는 배열에서 중복되는 종류번호를 unique를 사용해서 제거해준 후에 위에 두번째 과정을 해 주는 방법으로 좀 더 짧고 간단하게 코드를 짤 수 있다. 코드map을 사용한 코드123456789101112131415161718192021222324#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int solution(vector&lt;int&gt; nums){ int answer = 0; map&lt;int, int&gt; ponketmon; //step 1 for(int i = 0; i &lt; nums.size(); i++){ if(ponketmon.find(nums[i]) == ponketmon.end()) ponketmon[nums[i]] = 1; else ponketmon[nums[i]]++; } //step 2 if(ponketmon.size() &gt;= nums.size() / 2) answer = nums.size() / 2; else answer = ponketmon.size(); return answer;} unique를 사용한 코드1234567891011121314151617#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; nums){ int answer = 0; answer = nums.size() / 2; //unique함수 사용을 위해 정렬함.(step 1) sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); //step 2 if(nums.size() &lt; answer) answer = nums.size(); return answer;}","link":"/2021/04/01/programmers-1845/"},{"title":"(프로그래머스) 내적 (C++)","text":"문제 링크 문제길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이) 풀이문제에 주어진 내적 설명 링크에 의하면 내적이란 같은 인덱스에 해당하는 원소들의 곱의 합을 의미한다.주어지는 벡터는 길이가 같다고 했으므로 길이가 다를 걱정없이 같은 인덱스의 곱들을 구해서 차근차근 더해주면 문제가 해결된다. 코드12345678910111213#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; a, vector&lt;int&gt; b) { int answer = 1234567890; answer = 0; for(int i = 0; i &lt; a.size(); i++) answer += (a[i] * b[i]); return answer;}","link":"/2021/04/02/programmers-70128/"},{"title":"🏊‍♀️ 42서울 라피신 후기 (3)","text":"42서울 라피신 결과가 발표되어 마지막 라피신 후기를 씁니다… 다행히도 조금 여유가 있어 후기를 마무리 지을 수 있게 되었네요… 🎉 본과정 합격하하… 다행히 눈물의 후기를 쓰지 않아도 되었다..결론부터 말하자면 합격했다. 4기 본과정이 5월 3일에 시작하는 터라 한 4월 20일 정도에 발표가 나지 않을까? 하고 생각했었는데 예상보다는? 조금 늦게 나와서 한동안은 잊고 있다가 20일 즈음부터는 결과를 좀 기다렸던 것 같다. 슬랙에 갑자기 수고했다는 글이 올라오고, 같이 러쉬했던 팀원 중 한분이 떨어졌다는 소식을 전해주셔서 메일함에 가보니 알림이 씹힌(…) 본과정 합격 메일이 있었다.합격이란 결과를 받아본지가 너무 오래돼서 합격 발표가 나면 어떤 느낌일지 궁금했었는데 생각보다 덤덤해서 놀랐다. 그냥 와… 이게 되네… 하는 생각밖에 안들었다.아무튼… 내심 불합격하면 몇 안되는 라피신 불합격 후기를 쓸 수 있게 되지 않을까? 하고 생각하고있었는데… 네 아쉽게도(?) 합격 후기가 되었네요…ㅋㅋㅋ 재빠르게 킥오프 신청(예전에 라피신 신청 후에 했던거랑 비슷한 신청 확인 절차인 것 같다.)을 하고 나서야 조금 실감이 났다. 나 본과정 가는구나… 🤷‍♀️ 기준이 뭘까같이 고생했던 피시너들의 결과도 궁금하긴 했는데 생각해보니까 상대의 결과를 모르는 상태에서 ‘저 붙었는데 혹시 님 붙었어요?’ 이런 느낌으로 물어보기가 되게… 망설여져서 결국 먼저 연락주신 같이 러쉬한 팀원의 결과만 들었다.그래서 솔직히 말하면 합격 기준… 잘 모르겠습니다.ㅋㅋㅋ 연락주신 분은 레벨의 차이가 아닐까 라고 말씀해주시긴 했는데 (그분의 레벨보다 내 레벨이 높았음) 단순히 레벨로만 선발했을리는 절대 없고 다양한 기준이 있었겠죠? 근데 레벨이 높다는 것은 이것저것 많이 시도를 하고 결과도 어느정도 괜찮게 나왔다는 의미이기 때문에 레벨이 높다고 무조건 합격하는 것은 아니지만 레벨이 낮은데도 합격하신 분들은 다른 부분에서 뭔가 뛰어난 역량을 보여주셨기 때문에 합격하신게 아닐까.. 하는 생각을 한다.당연한 이야기일수도 있지만 42는 어떤 의미에서 투자를 하는 것이기 때문에 (교육을 하고 지원금을 주고….) 투자 가치가 있는 사람을 본과정으로 선발 할 것이고 어떻게 하면 투자 가치를 보일 수 있을까를 생각하면 대충 어떤 사람을 선발했을지 느낌정도는 오는 것 같다.그래서 내 생각에는 42의 커리큘럼 하에서 개발자로의 성장 가능성을 보인 사람 + 어느정도 실력이 향상되었거나 실력이 있는 사람을 다양한 척도로 판단하여 선발했을 것 같다. (정말 개인적인 생각입니다… 실력만 있는 사람도 뽑았을지도 몰라요…) 🏃‍♀️ 아무튼…아무튼 합격을 했고, 한달동안의 노력이 나름 42의 방향에 잘 맞았다는 것을 인정받은 것 같아 기분이 좋다. 그리고 5월, 6월에 엄청 바빠지게 될 것 같아 두려움 반 설레임 반인 심정이다. 지금도 죽어라 바쁜데 졸프, 프로젝트 과제, 본과정, 기말고사… 가 겹치게 생겼네요.. 흑흑 하지만 내가 좋아하는 일로 바쁠 수 있다는 것은 축복이라고 생각하기 때문에 일단은 … 일단은 행복하게 기다리겠습니다… 저도 여러 후기들을 보고 피신동안의 방향을 잡는데에 많은 도움을 받았었기 때문에 이 글을 읽어주시는 분들 중에 혹시라도 궁금한 점이 있으시다면 댓글 달아주시면 제가 답할 수 있는 범위 내에서는 최대한 답변을 해 드리도록 하겠습니다… 이렇게 라피신 후기를 마치게 되었다. 새삼스럽게 느끼는 거지만 나 정말 글 못쓴다… 정말 얼레벌레 쓴 후기인데 여기까지 읽어주신 분들 정말 수고 많으셨고 감사드립니다….","link":"/2021/04/23/42-seoul-la-piscine-review-3/"},{"title":"Libft (1)","text":"Libft Part 1. Libc의 함수들을 포함해서 앞으로 본과정에서 유용하게 쓰일 함수들이 담긴 C라이브러리를 직접 만드는 과제이다.이 과제를 하면서 조사하고 생각했던 것들을 정리해보았다. ft_memset12#include &lt;strings.h&gt;void *memset(void *b, int c, size_t len); b주소에서부터 len바이트만큼을 c라는 값으로 초기화한다. 코드 구현 시 고려사항 int 형 parameter c는 내부에서 unsigned char로 변환된다. (매뉴얼 내용) b는 void형 pointer이기 때문에 접근 할 때에 unsigned char로 형변환 해준 뒤에 접근해야 한다. char도 1바이트이고, unsigned char도 1바이트인데 왜 메모리를 접근하는 함수에서는 대부분(거의 다?) void*를 unsigned char*로 캐스팅하는지 궁금했는데 이유가 그나마 구체적으로 설명되어있는 글이 있었다. (참고) 간단히 정리하면 내부의 비트를 투명하게 볼 수 있어 좀 더 활용도(?)가 높은 unsigned char의 특성과, signed로 인해서 발생할 수 있는 여러가지 문제들(범위를 벗어난다거나, signed bit로 인해 표현할 수 있는 숫자들의 수가 줄어든다거나..) 등등으로 인해서 메모리 접근을 위해서는 unsigned char 형 포인터를 사용하는 것이 거의 관례적으로 굳어졌다는 것 같다… 그럼 왜 void*로 함수 프로토타입을 만들어 둔 것이냐 하면 확장성을 위해서! size_t size_t는 일반적으로는 unsigned int라고 정의되어 있다지만 확실하게 unsigned int라고도 할 수는 없는 것 같다. (size_t == unsigned int 가 항상 성립하면 굳이 unsigned int 를 사용할 필요가 없으니까…) 시스템마다 미묘하게 다른 메모리 공간의 크기를 정의하가 위해서 size_t라는 자료형을 만든 것 같다. size_t는 &lt;sys/types.h&gt;헤더에 정의되어있다고 하는데 이 헤더는 과제에서 사용되는 &lt;unistd.h&gt;나 &lt;stdlib.h&gt;에서도 인클루드되어있는 헤더이므로 굳이 다시 인클루드 해줄 필요는 없다고 생각한다. (참고) not-protected null입력을 별도로 처리해 줄 필요없다. ft_bzero12#include &lt;strings.h&gt;void bzero(void *s, size_t n); s주소에서부터 n바이트 만큼을 0으로 초기화한다.memset과 기능이 거의 유사해서인지 이제는 거의 사용하지 않는 함수라고 한다.memset(s, 0, n)이랑 결과가 같다. 코드 ft_memcpy12#include &lt;string.h&gt;void *memcpy(void *dst, const void *src, size_t n); src주소로부터 n개의 바이트를 dst주소에 복사한다.strcpy 함수와 비슷하다는 느낌이 들었는데 memcpy의 다른 점은 ‘\\0’을 확인하지 않고 무조건 n바이트를 복사한다는 점이다. 코드 구현 시 고려사항memory overlap이 있는 경우에는 정의되지 않은 행동을 한다고 한다. (매뉴얼 참고)이 정의되지 않은 행동이라는 것이 되게 신경쓰였는데 동료들과 상의해 본 결과 정의되지 않은 행동 (undefined behavior)라는 것을 이 상황에 대해서 이 함수가 할 행동에 대해서 책임지지 않겠다는 뜻이라고 해석했다.그래서 memory overlap 상황을 신경쓰지 않고 그냥 무조건 n바이트 복사하는 것으로 구현했다.memory overlap에 대해서도 고민했는데 그건 다른 함수(memmove)에서 자세히 적으려 한다. ft_memccpy12#include &lt;string.h&gt;void *memccpy(void *dst, const void *src, int c, size_t n); src의 주소에서 dst주소로 바이트 단위로 복사하는데 src에서 문자 c를 만날때까지 복사한다.만약 c를 만나지 못한다면 n바이트만큼을 복사한다. 코드 구현 시 고려사항 반환 값 src에서부터 n바이트 안에 c가 있을 경우 =&gt; dst에서 c다음 주소를 반환한다. src에서부터 n바이트 안에 c가 없을 경우 =&gt; NULL을 반환한다. ft_memmove12#include &lt;string.h&gt;void *memmove(void *dst, const void *src, size_t len); memcpy와 비슷하게 src의 n바이트를 dst에 복사한다.memcpy와의 차이점은 memmove에서는 dst와 src의 메모리공간이 overlap되는 경우도 고려해서 항상 non-destructive manner로 복사를 한다는 것이다. 코드 구현 시 고려사항 memory overlap?dst가 src보다 뒤에 있는 경우에 흔히 하는 방법대로 src의 첫 부분부터 복사를 하게되면 dst의 첫 부분과 src의 뒷 부분이 겹쳐져서(overlap) src의 뒷 부분이 손상될 가능성이 있다. non destructive mannersrc의 뒷부분이 손상될 가능성이 있는 경우(src &lt; dst)에도 문제없이 dst에 원래 있는 src의 내용들을 그대로 복사하려면 dst의 뒷부분에서부터 복사를 하면 dst의 위치와 상관없이 그대로 복사할 수 있다. Null 이 입력으로 들어왔을 때의 처리 방식 원본 memmove 함수에서 null 입력을 처리하는 것을 관찰하던 중에 dst와 src가 모두 null인 경우에는 null을 반환하고, 그 외에 둘 중 하나만 null인 경우에는 segmentation fault가 났다. 어떤 이유로 둘 다 null일 경우에만 처리해줬는지 궁금했는데 함수 내에서는 별도로 null 입력에 대한 처리를 해 주지 않았지만 예외 처리 1번을 처리하면서 동시에 둘다 null일 경우가 걸러진 것이 아닌가… 하는 생각이 들었다. 예외 처리 dst == src인 경우 =&gt; src나 dst나 똑같으니까 복사하지 않고 return (dst); len == 0 인 경우 =&gt; dst에 복사할 byte가 없으니까 복사하지 않고 return (dst); 개인적 삽질 + 앞으로 남은 42과제 해결에 있어서 깨달은 점 과제에 도움이 되는 여러 테스터를 돌리던 중 이상하게 다른 테스터에서는 통과가 되었는데 unit-test라는 테스터에서만 한 케이스가 자꾸 crush가 났다. memory range를 오버했다는 에러였는데 아무리 봐도 이상한 부분이 없어서 환장하다 기절 직전까지 갔을 때에 슬랙에서 같은 에러로 고통받으신 분의 스레드를 발견했다. 결론은 M1의 저주였다...(정확한 원인은 모르겠음) M1을 사용하는 분들에게 공통적으로 같은 테스터에서 같은 오류가 발생했었고, 과제 제출시에는 문제가 없었다고 한다...하하 구글링에는 한계가 있으니 42 과제를 하다가 모르는 점이 생기면 슬랙에 검색해보자! 특히 뒷 기수들은 앞 기수의 선배님들이 이런저런 오류들을 몸소 겪으며 슬랙에 기록을 해 두었기 때문에.. 나처럼 너무 늦게 찾아보지 말고 과제에 문제가 생겼다 하면 일단 슬랙을 검색하자... (허름) ft_memchr12#include &lt;string.h&gt;void *memchr(const void *s, int c, size_t n); s배열의 n bytes 내에서 가장 첫번째로 등장하는 c문자를 가리키는 포인터를 반환한다.만약 s배열의 n bytes 내에 c문자가 없으면 NULL을 반환한다. 코드 구현 시 고려사항 null입력에 대한 처리 n == 0 인 경우에는 NULL 반환 그 외에 s가 NULL인 경우에는 segmentatioin fault 발생 ft_memcmp12#include &lt;string.h&gt;int memcmp(const void *s1, const void *s2, size_t n); s1주소로부터 n바이트와 s2주소로부터 n바이트를 비교한다. 코드 구현 시 고려사항 두 배열의 길이는 nbytes인 것으로 간주한다.n bytes 이상이어야 한다는 것인지, 아니면 딱 n bytes여야 한다는 것인지 잘 모르겠다. 하지만 두 배열 모두 n bytes 미만이면 안된다는 것은 확실함.(매뉴얼 원문: Both strings are assumed to be n bytes long.)오버플로우 상관 없이 무조건 n바이트를 비교한다. 반환값 두 배열이 같은 경우에는 0을 반환한다. 두 배열이 다를 경우에는 첫번째로 다른 byte의 차이를 반환한다. (s1 - s2)=&gt; 이 때 연산은 unsigned char로 이루어져야 한다.\\200과 \\0을 비교하면 양수가 나와야 함. 길이가 0인 배열은 항상 같다. =&gt; n이 0일 경우에는 항상 0을 반환한다. NULL 입력에 관한 처리 두 배열 중 하나라도 null인 경우에는 segmentation fault를 발생시킨다. ft_strlen12#include &lt;string.h&gt;size_t strlen(const char *s); NULL문자 앞에 있는 문자의 개수를 반환한다. =&gt; 배열의 길이를 반환. 코드 ​ ft_strlcpy12#include &lt;string.h&gt;size_t strlcpy(char *dst, const char *src, size_t dstsize); src배열의 내용 중 dstsize - 1개의 문자를 dst에 복사한다. (1바이트는 ‘\\0’ 자리.)dstsize가 0이 아닌 경우에는 ‘\\0’로 마무리를 한다.src의 길이를 반환한다. 코드 구현 시 고려사항 protected? not protected? protected function이란 null 포인터의 입력이 들어왔을 때 함수 내부에서 null을 반환한다던가 해서 오류를 처리하는 함수 not protected function이란 null 포인터의 입력이 들어왔을 때를 고려하지 않고 구현된 함수. 대부분의 경우(모든 경우라고는 내가 잘 몰라서 할 수가 없겠다.) 세그멘테이션 폴트로 함수 실행이 종료된다. 프로텍트 여부에 대해서 동료들 사이에서도 의견이 분분했던 것 같은데 일단 원 함수인 strlcpy에서도 null 포인터가 입력되었을 때 세그폴트를 발생시켰기 때문에(not protected) ft_strlcpy를 not protected function으로 구현했다. 예외 처리 src == NULL || dst == NULL인 경우 Segmentation fault 발생시킴 dstsize == 0 복사는 진행하지 않고 그냥 src의 길이만 반환한다. ft_strlcat12#include &lt;string.h&gt;size_t strlcat(char *dst, const char *src, size_t dstsize); dst의 끝(‘\\0’문자 자리)에서부터 src의 문자들을 붙인다.작업이 완료된 후의 문자열의 길이가 최대 dstsize - 1이 되어야 한다 (1바이트는 ‘\\0’자리)’ 코드 구현 시 고려사항 dstsize의 의미 dstsize = dstlen + 붙이려는 글자 수 + 1 가능한 경우와 그 상황에서의 동작 dstlen &gt;= dstsize 복사하지 않는다. return (dstsize + srclen); srclen &lt; dstsize - dstlen 붙이려는 글자 수가 srclen보다 큰 경우 src 전체(null문자 까지)를 dst 뒤에 이어붙인다. (with memcpy) srclen &gt;= dstsize - dstlen 붙이려는 글자 수가 srclen과 같거나 큰 경우 길이가 같은 경우가 포함되는 이유는.. null문자 자리를 포함해줘야 하기 때문이다. srclen의 (dstsize - dstlen - 1)개 문자를 dst에 붙인 다음, 잊지 말고 null 종료를 해 준다. 반환값의 경우 복사를 안하는 경우 (dstlen &lt;= dstsize) =&gt; return (dstsize + srclen); 복사를 하는 경우 =&gt; return (dstlen + srclen); ft_strchr12#include &lt;string.h&gt;char *strchr(const char *s, int c); s문자열에서 c문자(converted to a char)의 포인터를 반환한다.만약 찾는 문자가 없다면 NULL 포인터를 반환한다. 코드 구현 시 고려사항 c에는 0이 들어갈수도 있음. null문자 포함해서 탐색해야 한다. 이전까지는 c를 unsigned char로 형변환했었는데 이번에는 char로 형변환 하는것에 주의하기. ft_strrchr12#include &lt;string.h&gt;char *strrchr(const char *s, int c); 문자열 s에서 가장 마지막에 있는 c문자의 포인터를 반환한다.만약 찾는 문자가 없다면 NULL 포인터를 반환한다. 코드 구현 시 고려사항 strchr와 마찬가지로 문자열에 ‘\\0’까지 포함한다. ft_strnstr12#include &lt;string.h&gt;char *strnstr(const char *haystack, const char *needle, size_t len); haystack에서 n바이트만큼을 탐색하면서 포함된 needle문자열의 시작 포인터를 반환한다.만약 일치하는 문자열이 없으면 null을 반환한다. 코드 구현 시 고려사항 needle의 마지막 ‘\\0’문자는 검색하지 않는다. (매뉴얼) (haystack 중간에 ‘\\0’이 있을 수는 없으니까.) 입력에 따른 결과 needle이 null인 경우에는 segfault를 발생시킨다. needle이 빈 문자열일 경우에는 haystack과 상관없이 haystack을 반환한다. (haystack이 null이면 null반환, 유효한 문자열이면 그 문자열 반환) len = 0이면 null 반환 그 외의 정상적이지 않은 입력에는 오류를 낸다. ft_strncmp12#include &lt;string.h&gt;int strncmp(const char *s1, const char *s2, size_t n); 문자열 s1과 s2에서 최대 n바이트만큼을 비교한다.이 함수는 binary data를 비교하는 것 보다는 string을 비교하는데에 중점을 두기 때문에 ‘\\0’ character 이상으로는 비교하지 않는다는 점이 memcmp와 다른 점이다. 코드 구현 시 고려사항 반환값 매뉴얼에 따르면 s1이 s2보다 클 경우에는 0보다 큰 정수 s1과 s2가 같을 경우에는 0 s1이 s2보다 작을 경우에는 0보다 작은 정수를 반환한다. 비교는 unsigned char를 이용하여 한다. =&gt; ‘\\200’이 ‘\\0’보다 크다. ft_atoi12#include &lt;stdlib.h&gt;int atoi(const char *str); ascii to int 코드 구현 시 고려사항 변환 과정 (이 순서로 입력되지 않으면 정상적으로 변환하지 않는다.) 공백 건너뛰기 (공백: 아스키코드 9~13번, ‘ ‘) 부호 결정하기 (- 등장하면 부호 변환하기) 피신때의 과제와 다른 점은 실제 atoi에서는 +든, -든 부호를 하나만 허용한다는 점이다. 만약 부호가 2개 이상 등장한다면 0을 반환해야 한다. 문자열이 끝나기 전까지, 숫자가 아닌 문자가 나오기 전까지의 문자들을 정수로 변환한다. int 범위의 최솟값의 절댓값이 int 범위의 최댓값보다 크기 때문에 변환할 숫자를 담을 변수를 int로 두면 int 범위 최솟값을 변환할 때에 문제가 생긴다.나는 절댓값을 unsigned int에 저장하도록 했다. int 범위 밖의 수에 대한 처리 int min 미만일 경우 atoi는 0을 반환한다. int max 초과일 경우 atoi는 -1을 반환한다. ft_isalpha12#include &lt;ctype.h&gt;int isalpha(int c); c(unsigned char로 변환)가 알파벳인지 확인한다.c가 알파벳이 아니면 0을 반환하고 알파벳이면 0이 아닌 수를 반환한다. (나는 1을 반환시켰다.) 코드 ft_isdigit12#include &lt;ctype.h&gt;int isdigit(int c); c(unsigned char로 변환)가 숫자 문자인지 확인한다.c가 숫자가 아니면 0을 반환하고 숫자면 0이 아닌 수를 반환한다. (나는 1을 반환시켰다.) 코드 ft_isalnum12 #include &lt;ctype.h&gt;int isalnum(int c); c에 대해서 isdigit 또는 isalpha가 참이 되는지를 확인한다.참이 아니면 0을 반환하고, 참이면 0이 아닌 수를 반환한다. (나는 1을 반환시켰다.) 코드 ft_isascii12#include &lt;ctype.h&gt;int isascii(int c); c가 아스키 문자인지를 확인한다. (which is any character between 0 and octal 0177 inclusive.) 코드 ft_isprint12#include &lt;ctype.h&gt;int isprint(int c); c(unsigned char로 변환)문자가 출력가능한 문자인지 판단한다.출력가능한 문자: 아스키코드 32~126 코드 ft_toupper12#include &lt;ctype.h&gt;int toupper(int c); c가 소문자일 경우에 대문자로 변환.소문자가 아닌 경우에는 아무것도 하지 않는다. 코드 ft_tolower12#include &lt;ctype.h&gt;int tolower(int c); c가 대문자일 경우에 소문자로 변환.대문자가 아닌 경우에는 아무것도 하지 않는다. 코드 ft_calloc12#include &lt;stdlib.h&gt;void *calloc(size_t count, size_t size); size bytes 크기의 object count개 만큼의 공간을 할당하고, 그 포인터를 반환한다.할당한 메모리는 모두 0을 할당한다. (bzero이용) 코드 ft_strdup12#include &lt;string.h&gt;char *strdup(const char *s1); s1문자열 길이 + 1만큼의 메모리를 할당한 다음 (with malloc) s1문자열을 복사한 후 반환한다.문자열일 경우에 '\\0' 마무리를 잊지 말자.. (Abort error로 30분 삽질함) 코드","link":"/2021/05/11/Libft-1/"},{"title":"Libft(2)","text":"Libft Part 2. protect vs. not-protectpart2에서 구현해야 하는 함수들은 특별히 원 함수가 있는 것이 아니라 특정한 기능을 수행하는 나만의 함수들을 구현하는 것이기 때문에 에러 입력에 관한 처리도 구현하는 사람 취향에 맞게 구현하면 된다. 이게 일반적인 용어인지, 아니면 Libft 테스터인 unit-test에서 임의로 만든 개념인지 모르겠지만(null protected function이라고 검색해 봤을 때 특별히 나오는 결과가 없어 보임) 포인터를 매개변수로 받는 함수에서 null포인터가 들어왔을 때 처리하는 방법에 따라서 protect, not-protect로 구분한다는 것 같다. null이 매개변수로 들어왔을 때 segment fault, bus error… 등의 에러를 뱉어내면 not-protect된 함수 null이 매개변수로 들어왔을 때 null을 반환한다던가 해서 비정상적인 종료를 막으면 protect 된 함수 처음에는 비정상적인 입력이 들어오면 함수를 비정상적으로 종료해서 사용자에게 이 입력이 비정상적임을 알리고 함수 진행을 중단해야 한다고 생각해서 protect를 안하는 쪽으로 part 2의 함수들을 구현했었는데 잘못된 입력이 들어왔을때 함수 실행을 완전히 중단해 버렸을 때 오는 피해가 잘못된 입력에서 오는 피해보다 더 클 수도 있다는 다른 분의 말씀에 설득되어 버려서…ㅎㅎ 다시 protect를 하는 쪽으로 모두 수정했다. 이 부분은 디펜스를 잘 할 수만 있다면 자신이 원하는 방향으로 구현을 하면 될 것 같다..! ft_substr1char *ft_substr(char const *s, unsigned int start, size_t len); s문자열의 start인덱스에서부터 최대 len바이트를 뽑아서(?) 새로운 부분 문자열을 만들고, 그 문자열의 시작 주소 반환하기 코드 예외 처리 s가 null일 경우 처리할 수 있는 문자열이 없으므로 null을 반환한다. s의 길이가 start보다 작거나 같은 경우 || len == 0 인 경우 처리는 가능하지만 유의미한 문자열을 생성할 수는 없기 때문에 빈 문자열을 반환한다. malloc이 실패한 경우 null을 반환한다. 함수 진행 과정 예외사항 (1, 2) 처리 slen(s 문자열의 길이)를 구해준 후에 min(len, slen - start) + 1만큼의 메모리 할당 s 문자열이 끝나기 전 ||복사한 문자의 개수가 len개 이하 까지 문자 복사해 넣기 마지막 인덱스에 null 문자 넣어주기 구현 시 고려사항 min(len, slen - start)의 이유 len이 부분문자열의 최대길이이기 때문이다. 만약 생성할 수 있는 문자열의 길이가 len보다 작은 경우에는 그만큼만 할당해서 문자열을 생성해야 한다. 사실 비교하지 않고 넉넉하게 len만큼만 할당해줘도 통과하는 것 같긴 하던데 나는 뭔가 여유롭게 할당해주는게 조금 신경쓰여서… 불필요한 과정이었다 해도 어쩔 수 없다!! ㅎㅎ s문자열의 내용을 새로운 문자열에 복사하는 형태이므로 ft_strlcpy를 활용하면 보다 깔끔한 코드를 짤 수 있을 것 같다는 생각을 했다. ft_strjoin1char *ft_strjoin(char const *s1, char const *s2); s1 문자열 뒤에 s2 문자열을 붙인 형태의 문자열을 생성해서 반환한다. 코드 예외 처리 s1과 s2 모두 null일 경우 처리할 수 있는 문자열이 없으므로 null을 반환한다. s1만 null인 경우 s2만 복제해서 반환한다. s2만 null인 경우 s1만 복제해서 반환한다. malloc 실패한 경우 null을 반환한다. 함수 진행 과정 예외 상황 (1, 2, 3) 처리 s1과 s2의 길이를 잰다. (with ft_strlen) (s1의 길이 + s2의 길이 + 1)만큼의 메모리를 할당해 준다. 할당한 메모리에 s1을 복사한다. (with ft_strlcpy) 그 뒤에 s2를 붙인다. (with ft_strlcat) 구현 시 고려사항 문제에서도 언급되었듯이 part 1에서 구현해 둔 함수를 part 2에서 활용할 수 있다. 문자열을 복사하는 과정은 ft_strlcpy로 대체할 수 있고 문자열을 붙이는 과정은 ft_strlcat으로 대체할 수 있다. 평가를 다니다 보면 코드가 길어져서 가독성이 떨어진다는 고민을 하는 동료들이 많았는데 과제의 목적을 잘 기억해서 중복되는 코드를 작성하지 않게 하면 보다 효율적인 코드를 작성할 수 있을 것 같다. ft_strlcat과 ft_strlcpy의 마지막 매개변수에 주의하자. ft_strlcat의 마지막 매개변수는 **함수가 반환할 문자열의 길이 + 1 (null 문자 크기)**이다. 따라서 (s1의 길이 + s2의 길이 + 1)을 매개변수로 전달해주었다. ft_strlcpy의 마지막 매개변수는 **복사할 문자의 개수 + 1 (null 문자 크기)**이다. 따라서 (s1의 길이 + 1)을 매개변수로 전달해주었다. ft_strtrim1char *ft_strtrim(char const *s1, char const *set); s1의 앞, 뒤에서 set에 포함되어 있는 문자들을 모두 제거한 형태의 문자열을 생성하여 반환한다. 예) s1: “aabcdabdcaab” set: “ab” =&gt; “cdbabdc” 코드 예외 처리 s1이 null일 경우 처리할 문자열이 없으므로 null을 반환한다. set이 null일 경우 제거할 문자가 없으므로 s1을 복제하여 반환한다 s1의 모든 문자가 set에 포함된 경우 s1의 모든 문자가 제거되므로 빈 문자열을 반환한다. malloc 실패할 경우 null을 반환한다. 함수 진행 과정 예외 상황 (1, 2) 처리 s1 문자열의 시작과 끝으로 시작 포인터 (start), 끝 포인터 (end) 설정 문자열의 앞에서 set에 포함된 문자가 등장하지 않을 때 까지 start 이동시키기 예외 상황 (3) 처리 문자열의 뒤에서 set에 포함된 문자가 등장하지 않을 때 까지 end 이동시키기 문자열의 길이 계산하고 (len = end - start + 1) 메모리 할당하기 할당한 공간에 start부터 len만큼의 문자 복사하기 (with ft_strlcpy) 구현 시 고려사항 모든 문자가 삭제되는 상황 파악하기 처음에는 start &gt; end 인 상황에서 모든 문자가 삭제됨을 확인하고 빈 문자열을 반환하는 방법을 했었는데 실제로 모든 문자가 삭제되는 상황에서 자꾸 abort가 떠서 원인을 찾아보았더니 문제는 end를 움직이는 상황에서 end를 포인터를 이용해서 움직이다보니 end가 문장 끝(문장의 시작부분)을 넘어가는 상황에서 반복을 멈추지 못하는 것이었다. 길이를 먼저 재서 길이를 줄여가면서 모든 문자가 삭제되었는지 확인해보는 등 여러가지 방법을 생각해보긴 했었는데 start를 움직이는데 있어서는 문제가 없었기 때문에 그냥 start를 움직인 다음에 모든 문자가 삭제되었는지 (start가 null에 도달했는지)를 확인해 본 후에 end를 움직이는 것이 가장 간단하게 확인할 수 있는 방법이었다. 함수의 기능을 이해하는데 어려움이 있었다. set에 포함된 문자들을 모두 s1에서 제거하는 것이 아니라 앞 뒤에 있는 문자들 (set에 포함되어 있지 않은 문자 안쪽에 있는 문자는 고려할 필요가 없음)만 제거하면 되는 것이다. (위에 적어둔 예시 참고) ft_split12char **ft_split(char const *s, char c); s 문자열을 c 문자열을 기준으로 나누어서 만들어진 문자열의 배열을 반환하기. 코드 예외 처리 s가 null인 경우 null을 반환한다. 문자열 배열의 메모리 할당이 실패한 경우 null을 반환한다. 문자열의 메모리 할당이 실패한 경우 그동안 할당해 준 메모리들을 모두 해제해 준 다음에 null을 반환한다. (all_free 함수) 함수 진행 과정 예외 상황(1) 처리 만들어질 문자열의 개수를 세어준다 (get_cnt_strs) s에서 c가 등장하지 않을 때까지 인덱스를 이동시킨다. c가 아닌 문자가 등장한 경우 cnt를 늘려주고 c가 등장하지 않을 때까지 인덱스를 이동시킨다. (한 문자열) c가 등장한 경우 인덱스를 1 증가시킨다. (문자열의 개수 + 1) * sizeof(char *) 만큼의 메모리를 할당한다. (예외 상황 (2) 처리) 문자열의 개수만큼 문자열을 생성하여 문자열 배열에 넣어준다. (with get_str) 문자열의 시작 포인터와 문자열의 길이를 전달하여 새로운 문자열의 시작 포인터와 문자열의 길이를 반환받는다. 예외상황 (3) 처리 문자열을 붙여넣는다. (with ft_strlcpy) 배열의 마지막은 null로 마무리한다. 구현 시 고려사항 피신 때도 비슷한 문제가 있었는데 그때 코드를 활용하니 함수 줄 제한을 지키는 데에 어려움이 있어서 다른 분의 코드를 참고했다. 어떤 곳에서 함수를 정의해주느냐가 관건인 것 같다. ft_itoa1char *ft_itoa(int n); int로 주어지는 숫자를 문자열로 변환해준다. 코드 예외 처리 malloc이 실패할 경우 null을 반환한다. 코드 진행 과정&lt;추가예정&gt; 부호 판단하기 절댓값 계산하기 문자열의 길이 계산하기 뒤에서부터 차례로 숫자 넣어주기 (10으로 나눈 나머지) 음수일 경우 인덱스 0 자리에 - 넣어주고 양수일 경우에는 나머지 숫자 넣어주기 구현 시 고려사항 int형 변수들을 처리할 때는 음수 최댓값의 절댓값이 양수 최댓값보다 크다는 사실을 꼭 기억하고 있어야 한다. 음수 최댓값이 양수 최댓값의 범위를 벗어나는 것을 고려해서 절댓값은 unsigned int 형으로 저장했다. 문자열의 길이를 생각할 때에 음수는 앞에 ‘-‘가 들어가야 하기 때문에 문자열의 길이가 1부터 시작한다는 점을 기억해두어야 한다. ft_strmapi1char *ft_strmapi(char const *s, char (*f)(unsigned int, char)); s 문자열의 각각의 문자에 함수 포인터로 주어지는 함수 f를 적용한 새로운 문자열을 반환하기 코드 예외 처리 s 또는 f가 null인 경우 문자열을 처리 할 방법이 없으므로 null을 반환한다. malloc 실패한 경우 null을 반환한다. 코드 진행 과정 예외 상황 (1) 처리 (문자열 길이 + 1)만큼 메모리 할당 (예외 상황 (2) 처리) 문자열의 문자 각각에 f 적용해주기 문자열 끝에 null 종료해주기 구현 시 고려사항 f의 매개변수에 대한 자세한 설명이 없어서 unsigned int 로 받는 매개변수 i가 무슨 의미인지 궁금했는데 결국에는 다른 분들의 코드를 보고 인덱스에 해당하는 것이구나.. 하는 것을 알게 되었다.ft_putchar_fd1void ft_putchar_fd(char c, int fd); fd 로 주어지는 파일에 문자 c 출력하기 코드 예외 처리 fd가 음수일 경우 출력하지 않고 반환한다. 구현 시 고려사항 fd가 음수일 경우를 고려해 주어야 한다. 파일 디스크립터는 모두 0 또는 양의 정수인줄 알았는데 파일 open이 정상적으로 되지 않았을 경우에는 파일 디스크립터가 음수도 나올 수 있다고 한다. fd가 음수일 경우에는 write에서 오류가 생기므로 (쓸 파일이 정상적으로 열리지 않았기 때문에) 출력하지 않고 그대로 반환해주어야 한다. ft_putstr_fd1void ft_putstr_fd(char *s, int fd); fd로 주어지는 파일에 문자열 s 출력하기 코드 예외 처리 s가 null이거나 fd가 음수인 경우 출력이 불가능하므로 그냥 반환한다. ft_putendl_fd1void ft_putendl_fd(char *s, int fd); fd 로 주어지는 파일에 문자열 s 를 출력하고 개행 출력하기 코드 예외 처리 s가 null이거나 fd가 음수인 경우 출력이 불가능하므로 그냥 반환한다. ft_putnbr_fd1void ft_putnbr_fd(int n, int fd); fd로 주어지는 파일에 int n 출력하기 코드 예외 처리 fd가 음수일 경우 출력하지 않고 반환한다. 구현 시 고려사항 itoa를 사용하면 좀 더 깔끔한 코드를 짤 수 있었을 것 같은데 허용 함수에 free가 없어서 메모리 leak 발생으로 itoa를 사용할 수 없었다… 하하","link":"/2021/05/14/Libft-2/"},{"title":"(Do it! 자바스크립트) Chapter 1. 안녕? 자바스크립트!","text":"Do it! 웹 프로그래밍을 위한 자바스크립트 기본 편을 읽고, 공부하고, 정리한 글책 정보 공부한 내용을 정리하기 위한 목적의 글입니다.정확하고 자세한 내용 확인을 위해서 책을 구입하셔서 공부하시는 것을 권장합니다.😀 들어가며사실 나는 책으로 공부하는 것을 별로 좋아하지 않는 사람이었다. 책에 있는 정보를 공부하는 것 보다는 실제로 구현해보면서 그때그때 필요한 정보들을 구글링해서 찾아보는 방식의 공부 방법이 더 좋을 것이라는 생각을 하고 있었는데 (교재가 없는 학습… 42의 정신인가..?!) 요즘 들어 그 생각이 조금은 틀렸을 수도 있겠다는 생각이 들어서 책을 구입하였다.확실히 조금 아는 상태에서는 방대한 지식들 속에서 유용한 정보만을 쏙쏙 골라서 잘 공부할 수 있겠지만 완전히 처음 공부하는 상태에서는… 별로 정제된 정보를 얻을 수 있을 것 같지 않았다. 아니, 얻을 수 없었다.😂지금 급하게 하고 있는 졸업 프로젝트에서도 자바스크립트를 사용하고 있는데 어줍잖게 알고 있는 상태에서 열심히 구글링해서 짠 코드는.. 공부해서 진짜 알고 짰다기보다는 그냥 잘 끼워맞춰서 완성된? 그런 느낌이 강했다. 어디 나가서 자랑스럽게 선보일수는 없겠다는 생각이 문득 들어 자바스크립트의 기본을 확실하게 공부해야겠다는 결심을 했고, 무분별한 구글링으로 이 사단(?)이 났으니 보다 정제된 지식을 얻을 수 있는 책으로 공부하기로 했다. 웹 프로그래밍이란?[웹 사이트가 작동하는 과정]클라이언트가 서버에 필요한 정보를 웹 사이트를 통해서 요청을 하면 서버에서 요청을 받아 알맞은 정보를 전달한다.사용자는 서버로부터 받은 정보를 웹 사이트를 통해서 확인할 수 있[웹 프로그래밍]웹 프로그래밍은 백엔드(Back-end)와 프론트엔드(Front-end) 개발로 나뉘어지는데백엔드 개발은 서버에서 사용자의 요청을 처리하고, 데이터를 관리하는 것을 담당하고프론트엔드 개발은 받아온 정보를 웹 브라우저에 어떻게 보여줄 것인지를 담당한다. 자바스크립트로 무엇을 할 수 있을까[웹 사이트를 동적으로 만들 수 있다.]HTML과 CSS는 웹 사이트의 외관만을 담당한다.따라서 웹 사이트에 동적인 효과(포인터가 올라갔을 때 메뉴가 펼쳐진다거나, 화면을 넘긴다던가 하는 것들)를 추가하기 위해서는 자바스크립트를 사용해야 한다. [웹 브라우저에서 실행되는 프로그램을 만들 수 있다.]웹을 동적으로 만드는 것 뿐만 아니라 웹에서 작동하는 프로그램도 만들 수 있다. [서버를 구성하고 서버용 프로그램을 만들 수 있다.]과거에는 서버 프로그램을 만들기 위해서 PHP, 자바 같은 언어들을 따로 공부했었어야 했지만 현재는 자바스크립트로도 서버 프로그램을 만들 수 있다.Node.js라는 자바스크립트 프레임워크를 사용하면 서버 프로그램을 개발할 수 있다.✏️ 자바스크립트 프레임워크: 자바스크립트 기반의 프레임워크(…) 위키백과 자바스크립트의 특징은 무엇일까?[모든 웹 브라우저에서 작동한다.]자바스크립트는 웹 브라우저의 종류가 적었던 초창기부터 사용했던 언어이기 때문에 현재의 대부분의 웹 브라우저에서 작동한다.다만 자바스크립트의 모든 문법이 현재의 브라우저에서 모두 사용할 수 있는 것은 아니기 때문에 주의해야 한다.✏️ 자바스크립트의 버전: 자바스크립트가 에크마스크립트(ECMAScript)가 된 이후부터 1년에 한번씩 기능이 업그레이드 된 버전을 발표하고 있다고 한다. (에크마스크립트와 자바스크립트의 관계에 대해서 자세히 설명해 주신 글: 링크) 현업에서는 주로 브라우저의 호환성을 위해서 ES5까지의 문법을 주로 사용하는데 현재의 최신 문법은 아마도… ES12라는 것 같다! [웹 브라우저에서 실행 결과를 즉시 확인할 수 있다.]자바스크립트로 작성한 코드는 별도의 프로그램을 설치하지 않아도 웹 브라우저에서 바로 실행시켜 볼 수 있다. [풀스택 웹 개발 뿐 아니라 다양한 용도의 프로그램을 만들 수 있다.]자바스크립트로 프론트엔드와 백엔드를 모두 제어할 수 있고, 웹 개발 뿐 아니라 아두이노, 드론과 같은 IoT 관련 프로그램도 개발할 수 있다. [다양한 자바스크립트 공개 API를 사용할 수 있다.]요즘 다양한 목적의 API가 제공되고 있는데 많은 경우 그 API들은 자바스크립트로 만들어져 있다. 자바스크립트를 이용하면 API 또한 편하게 이용할 수 있다. [다양한 라이브러리와 프레임워크를 사용할 수 있다.] 자바스크립트 라이브러리: 자바스크립트로 미리 구현해 놓은 기능을 묶어 놓은 것(예: jQuery,,,) 자바스크립트 프레임워크: 프레임워크에서 기본으로 제공하는 소스를 수정하거나 추가하는 방법으로 웹 프로그램을 만들 수 있게 하는 일종의 틀 (예: Angular, Vue,,,)","link":"/2021/05/22/DO-it-JS-1/"}],"tags":[{"name":"정제되지않은이야기들","slug":"정제되지않은이야기들","link":"/tags/%EC%A0%95%EC%A0%9C%EB%90%98%EC%A7%80%EC%95%8A%EC%9D%80%EC%9D%B4%EC%95%BC%EA%B8%B0%EB%93%A4/"},{"name":"42Seoul","slug":"42Seoul","link":"/tags/42Seoul/"},{"name":"La piscine","slug":"La-piscine","link":"/tags/La-piscine/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"DailyCoding","slug":"DailyCoding","link":"/tags/DailyCoding/"},{"name":"Programmers","slug":"Programmers","link":"/tags/Programmers/"},{"name":"Libft","slug":"Libft","link":"/tags/Libft/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"StudyWithBook","slug":"StudyWithBook","link":"/tags/StudyWithBook/"}],"categories":[{"name":"42 Seoul","slug":"42-Seoul","link":"/categories/42-Seoul/"},{"name":"La piscine","slug":"42-Seoul/La-piscine","link":"/categories/42-Seoul/La-piscine/"},{"name":"Daily Coding","slug":"Daily-Coding","link":"/categories/Daily-Coding/"},{"name":"Programmers","slug":"Daily-Coding/Programmers","link":"/categories/Daily-Coding/Programmers/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Do it JS","slug":"Study/Do-it-JS","link":"/categories/Study/Do-it-JS/"}]}